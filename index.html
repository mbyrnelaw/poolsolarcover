<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pool Heating Simulation with Solar Cover</title>
    <style>
        body { font-family: Arial, sans-serif; }
        #controls { margin-top: 20px; }
    </style>
</head>
<body>
    <h1>Interactive Pool Heating Simulation</h1>
    <p>Use the slider to adjust the jet angle (-90° = downward, 0° = horizontal, 90° = upward towards the cover). Click Start to run the simulation, Reset to stop and reset.</p>
    <p>This simulation models fluid dynamics and heat transfer using Navier-Stokes equations for incompressible flow. Heat is transferred from the solar cover to the surface layer with convection enhanced by surface turbulence. The jet introduces turbulent flow, and temperature variations are shown locally in the pool cross-section.</p>
    <canvas id="poolCanvas" width="600" height="400" style="border:1px solid black;"></canvas>
    <div id="controls">
        <label for="angle">Jet Angle (degrees, -90 down, 0 horizontal, 90 up): </label>
        <input type="range" id="angle" min="-90" max="90" value="0" step="1">
        <span id="angleValue">0°</span>
        <br>
        <button id="startBtn">Start Simulation</button>
        <button id="resetBtn">Reset</button>
        <p id="status"></p>
    </div>
    <script>
        var canvas = document.getElementById('poolCanvas');
        var ctx = canvas.getContext('2d');
        var angleSlider = document.getElementById('angle');
        var angleValue = document.getElementById('angleValue');
        var startBtn = document.getElementById('startBtn');
        var resetBtn = document.getElementById('resetBtn');
        var status = document.getElementById('status');

        var time = 0; // in arbitrary units
        var interval = null;
        var solver;

        function FSolver(nx, ny, dt, visc, diff) {
            this.nx = nx;
            this.ny = ny;
            this.dt = dt;
            this.visc = visc;
            this.diff = diff;
            this.numCells = (nx + 2) * (ny + 2);
            this.u = new Float32Array(this.numCells).fill(0);
            this.v = new Float32Array(this.numCells).fill(0);
            this.uOld = new Float32Array(this.numCells).fill(0);
            this.vOld = new Float32Array(this.numCells).fill(0);
            this.density = new Float32Array(this.numCells).fill(20);
            this.densityOld = new Float32Array(this.numCells).fill(0);
            this.wrap_x = false;
            this.wrap_y = false;
        }

        FSolver.prototype.IX = function(x, y) {
            return x + y * (this.nx + 2);
        };

        FSolver.prototype.SWAP = function(field1, field2) {
            var tmp = this[field1];
            this[field1] = this[field2];
            this[field2] = tmp;
        };

        FSolver.prototype.addSource = function(x, x0) {
            for (var size = this.numCells - 1; size >= 0; size--) {
                x[size] += this.dt * x0[size];
            }
        };

        FSolver.prototype.addCellVelocity = function() {
            this.addSource(this.u, this.uOld);
            this.addSource(this.v, this.vOld);
        };

        FSolver.prototype.setBoundary = function(bound, x) {
            var dst1, dst2, src1, src2, i;
            var step = this.IX(0, 1) - this.IX(0, 0);
            dst1 = this.IX(0, 1);
            src1 = this.IX(1, 1);
            dst2 = this.IX(this.nx + 1, 1);
            src2 = this.IX(this.nx, 1);

            if (this.wrap_x) {
                src1 ^= src2;
                src2 ^= src1;
                src1 ^= src2;
            }

            if (bound === 1 && !this.wrap_x) {
                for (i = this.ny; i > 0; i--) {
                    x[dst1] = -x[src1]; dst1 += step; src1 += step;
                    x[dst2] = -x[src2]; dst2 += step; src2 += step;
                }
            } else {
                for (i = this.ny; i > 0; i--) {
                    x[dst1] = x[src1]; dst1 += step; src1 += step;
                    x[dst2] = x[src2]; dst2 += step; src2 += step;
                }
            }

            dst1 = this.IX(1, 0);
            src1 = this.IX(1, 1);
            dst2 = this.IX(1, this.ny + 1);
            src2 = this.IX(1, this.ny);

            if (this.wrap_y) {
                src1 ^= src2;
                src2 ^= src1;
                src1 ^= src2;
            }

            if (bound === 2 && !this.wrap_y) {
                for (i = this.nx; i > 0; i--) {
                    x[dst1++] = -x[src1++];
                    x[dst2++] = -x[src2++];
                }
            } else {
                for (i = this.nx; i > 0; i--) {
                    x[dst1++] = x[src1++];
                    x[dst2++] = x[src2++];
                }
            }

            x[this.IX(0, 0)] = 0.5 * (x[this.IX(1, 0)] + x[this.IX(0, 1)]);
            x[this.IX(0, this.ny + 1)] = 0.5 * (x[this.IX(1, this.ny + 1)] + x[this.IX(0, this.ny)]);
            x[this.IX(this.nx + 1, 0)] = 0.5 * (x[this.IX(this.nx, 0)] + x[this.IX(this.nx + 1, 1)]);
            x[this.IX(this.nx + 1, this.ny + 1)] = 0.5 * (x[this.IX(this.nx, this.ny + 1)] + x[this.IX(this.nx + 1, this.ny)]);
        };

        FSolver.prototype.diffuse = function(bound, x, x0, diff) {
            var a_x = this.dt * diff * this.nx * this.nx;
            var a_y = this.dt * diff * this.ny * this.ny;
            for (var k = 0; k < 20; k++) {
                for (var i = 1; i <= this.nx; i++) {
                    for (var j = 1; j <= this.ny; j++) {
                        var ix = this.IX(i, j);
                        x[ix] = (x0[ix] + a_x * (x[this.IX(i - 1, j)] + x[this.IX(i + 1, j)]) + a_y * (x[this.IX(i, j - 1)] + x[this.IX(i, j + 1)])) / (1 + 2 * a_x + 2 * a_y);
                    }
                }
                this.setBoundary(bound, x);
            }
        };

        FSolver.prototype.advect = function(bound, d, d0, u, v) {
            var dt0x = this.dt * this.nx;
            var dt0y = this.dt * this.ny;
            for (var i = 1; i <= this.nx; i++) {
                for (var j = 1; j <= this.ny; j++) {
                    var x = i - dt0x * u[this.IX(i, j)];
                    var y = j - dt0y * v[this.IX(i, j)];
                    if (x < 0.5) x = 0.5;
                    if (x > this.nx + 0.5) x = this.nx + 0.5;
                    var i0 = Math.floor(x);
                    var i1 = i0 + 1;
                    if (y < 0.5) y = 0.5;
                    if (y > this.ny + 0.5) y = this.ny + 0.5;
                    var j0 = Math.floor(y);
                    var j1 = j0 + 1;
                    var s1 = x - i0;
                    var s0 = 1 - s1;
                    var t1 = y - j0;
                    var t0 = 1 - t1;
                    var ix = this.IX(i, j);
                    d[ix] = s0 * (t0 * d0[this.IX(i0, j0)] + t1 * d0[this.IX(i0, j1)]) + s1 * (t0 * d0[this.IX(i1, j0)] + t1 * d0[this.IX(i1, j1)]);
                }
            }
            this.setBoundary(bound, d);
        };

        FSolver.prototype.project = function(u, v, p, div) {
            for (var i = 1; i <= this.nx; i++) {
                for (var j = 1; j <= this.ny; j++) {
                    var ix = this.IX(i, j);
                    div[ix] = -0.5 * ((u[this.IX(i + 1, j)] - u[this.IX(i - 1, j)]) * this.nx + (v[this.IX(i, j + 1)] - v[this.IX(i, j - 1)]) * this.ny);
                    p[ix] = 0;
                }
            }
            this.setBoundary(0, div);
            this.setBoundary(0, p);
            for (var k = 0; k < 20; k++) {
                for (var i = 1; i <= this.nx; i++) {
                    for (var j = 1; j <= this.ny; j++) {
                        var ix = this.IX(i, j);
                        p[ix] = (div[ix] + p[this.IX(i - 1, j)] + p[this.IX(i + 1, j)] + p[this.IX(i, j - 1)] + p[this.IX(i, j + 1)]) / 4;
                    }
                }
                this.setBoundary(0, p);
            }
            for (var i = 1; i <= this.nx; i++) {
                for (var j = 1; j <= this.ny; j++) {
                    var ix = this.IX(i, j);
                    u[ix] -= 0.5 * (p[this.IX(i + 1, j)] - p[this.IX(i - 1, j)]) * this.nx;
                    v[ix] -= 0.5 * (p[this.IX(i, j + 1)] - p[this.IX(i, j - 1)]) * this.ny;
                }
            }
            this.setBoundary(1, u);
            this.setBoundary(2, v);
        };

        FSolver.prototype.updateDensity = function() {
            this.addSource(this.density, this.densityOld);
            this.SWAP('density', 'densityOld');
            this.diffuse(0, this.density, this.densityOld, this.diff);
            this.SWAP('density', 'densityOld');
            this.advect(0, this.density, this.densityOld, this.u, this.v);
        };

        FSolver.prototype.updateVelocity = function() {
            this.addCellVelocity();
            this.SWAP('u', 'uOld');
            this.diffuse(1, this.u, this.uOld, this.visc);
            this.SWAP('v', 'vOld');
            this.diffuse(2, this.v, this.vOld, this.visc);
            this.project(this.u, this.v, this.uOld, this.vOld);
            this.SWAP('u', 'uOld');
            this.SWAP('v', 'vOld');
            this.advect(1, this.u, this.uOld, this.uOld, this.vOld);
            this.advect(2, this.v, this.vOld, this.uOld, this.vOld);
            this.project(this.u, this.v, this.uOld, this.vOld);
        };

        function updateAngleValue() {
            angleValue.innerHTML = angleSlider.value + '°';
        }

        angleSlider.oninput = function() {
            updateAngleValue();
            drawPool();
        };

        function drawPool() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw pool temperature grid
            var cellW = 500 / solver.nx;
            var cellH = 250 / solver.ny;
            var avgT = 0;
            for (var j = 1; j <= solver.ny; j++) {
                for (var i = 1; i <= solver.nx; i++) {
                    var T = solver.density[solver.IX(i, j)];
                    avgT += T;
                    var hue = 240 - (T - 20) * 24;
                    hue = Math.max(0, hue);
                    ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                    ctx.fillRect(50 + (i - 1) * cellW, 100 + (j - 1) * cellH, cellW, cellH);
                }
            }
            avgT /= (solver.nx * solver.ny);

            // Solar cover
            ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.fill
