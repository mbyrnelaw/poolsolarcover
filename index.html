<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pool Heating Simulation with Solar Cover</title>
    <style>
        body { font-family: Arial, sans-serif; }
        #controls { margin-top: 20px; }
    </style>
</head>
<body>
    <h1>Interactive Pool Heating Simulation</h1>
    <p>Use the slider to adjust the jet angle (-90° = downward, 0° = horizontal, 90° = upward towards the cover). Click Start to run the simulation, Reset to stop and reset.</p>
    <p>This simulation models fluid dynamics and heat transfer using Navier-Stokes equations for incompressible flow. Heat is transferred from the solar cover to the surface layer with convection enhanced by surface turbulence. The jet introduces turbulent flow, and temperature variations are shown locally in the pool cross-section. Velocity arrows visualize the flow, including the jet stream.</p>
    <canvas id="poolCanvas" width="600" height="400" style="border:1px solid black;"></canvas>
    <div id="controls">
        <label for="angle">Jet Angle (degrees, -90 down, 0 horizontal, 90 up): </label>
        <input type="range" id="angle" min="-90" max="90" value="0" step="1">
        <span id="angleValue">0°</span>
        <br>
        <button id="startBtn">Start Simulation</button>
        <button id="resetBtn">Reset</button>
        <p id="status"></p>
    </div>
    <script>
        var canvas = document.getElementById('poolCanvas');
        var ctx = canvas.getContext('2d');
        var angleSlider = document.getElementById('angle');
        var angleValue = document.getElementById('angleValue');
        var startBtn = document.getElementById('startBtn');
        var resetBtn = document.getElementById('resetBtn');
        var status = document.getElementById('status');

        var time = 0; // in arbitrary units
        var interval = null;
        var solver;

        function FSolver(nx, ny, dt, visc, diff) {
            this.nx = nx;
            this.ny = ny;
            this.dt = dt;
            this.visc = visc;
            this.diff = diff;
            this.numCells = (nx + 2) * (ny + 2);
            this.u = new Float32Array(this.numCells).fill(0);
            this.v = new Float32Array(this.numCells).fill(0);
            this.uOld = new Float32Array(this.numCells).fill(0);
            this.vOld = new Float32Array(this.numCells).fill(0);
            this.density = new Float32Array(this.numCells).fill(20);
            this.densityOld = new Float32Array(this.numCells).fill(0);
            this.wrap_x = false;
            this.wrap_y = false;
        }

        FSolver.prototype.IX = function(x, y) {
            return x + y * (this.nx + 2);
        };

        FSolver.prototype.SWAP = function(field1, field2) {
            var tmp = this[field1];
            this[field1] = this[field2];
            this[field2] = tmp;
        };

        FSolver.prototype.addSource = function(x, x0) {
            for (var size = this.numCells - 1; size >= 0; size--) {
                x[size] += this.dt * x0[size];
            }
        };

        FSolver.prototype.addCellVelocity = function() {
            this.addSource(this.u, this.uOld);
            this.addSource(this.v, this.vOld);
        };

        FSolver.prototype.setBoundary = function(bound, x) {
            var dst1, dst2, src1, src2, i;
            var step = this.IX(0, 1) - this.IX(0, 0);
            dst1 = this.IX(0, 1);
            src1 = this.IX(1, 1);
            dst2 = this.IX(this.nx + 1, 1);
            src2 = this.IX(this.nx, 1);

            if (this.wrap_x) {
                src1 ^= src2;
                src2 ^= src1;
                src1 ^= src2;
            }

            if (bound === 1 && !this.wrap_x) {
                for (i = this.ny; i > 0; i--) {
                    x[dst1] = -x[src1]; dst1 += step; src1 += step;
                    x[dst2] = -x[src2]; dst2 += step; src2 += step;
                }
            } else {
                for (i = this.ny; i > 0; i--) {
                    x[dst1] = x[src1]; dst1 += step; src1 += step;
                    x[dst2] = x[src2]; dst2 += step; src2 += step;
                }
            }

            dst1 = this.IX(1, 0);
            src1 = this.IX(1, 1);
            dst2 = this.IX(1, this.ny + 1);
            src2 = this.IX(1, this.ny);

            if (this.wrap_y) {
                src1 ^= src2;
                src2 ^= src1;
                src1 ^= src2;
            }

            if (bound === 2 && !this.wrap_y) {
                for (i = this.nx; i > 0; i--) {
                    x[dst1++] = -x[src1++];
                    x[dst2++] = -x[src2++];
                }
            } else {
                for (i = this.nx; i > 0; i--) {
                    x[dst1++] = x[src1++];
                    x[dst2++] = x[src2++];
                }
            }

            x[this.IX(0, 0)] = 0.5 * (x[this.IX(1, 0)] + x[this.IX(0, 1)]);
            x[this.IX(0, this.ny + 1)] = 0.5 * (x[this.IX(1, this.ny + 1)] + x[this.IX(0, this.ny)]);
            x[this.IX(this.nx + 1, 0)] = 0.5 * (x[this.IX(this.nx, 0)] + x[this.IX(this.nx + 1, 1)]);
            x[this.IX(this.nx + 1, this.ny + 1)] = 0.5 * (x[this.IX(this.nx, this.ny + 1)] + x[this.IX(this.nx + 1, this.ny)]);
        };

        FSolver.prototype.diffuse = function(bound, x, x0, diff) {
            var a_x = this.dt * diff * this.nx * this.nx;
            var a_y = this.dt * diff * this.ny * this.ny;
            for (var k = 0; k < 20; k++) {
                for (var i = 1; i <= this.nx; i++) {
                    for (var j = 1; j <= this.ny; j++) {
                        var ix = this.IX(i, j);
                        x[ix] = (x0[ix] + a_x * (x[this.IX(i - 1, j)] + x[this.IX(i + 1, j)]) + a_y * (x[this.IX(i, j - 1)] + x[this.IX(i, j + 1)])) / (1 + 2 * a_x + 2 * a_y);
                    }
                }
                this.setBoundary(bound, x);
            }
        };

        FSolver.prototype.advect = function(bound, d, d0, u, v) {
            var dt0x = this.dt * this.nx;
            var dt0y = this.dt * this.ny;
            for (var i = 1; i <= this.nx; i++) {
                for (var j = 1; j <= this.ny; j++) {
                    var x = i - dt0x * u[this.IX(i, j)];
                    var y = j - dt0y * v[this.IX(i, j)];
                    if (x < 0.5) x = 0.5;
                    if (x > this.nx + 0.5) x = this.nx + 0.5;
                    var i0 = Math.floor(x);
                    var i1 = i0 + 1;
                    if (y < 0.5) y = 0.5;
                    if (y > this.ny + 0.5) y = this.ny + 0.5;
                    var j0 = Math.floor(y);
                    var j1 = j0 + 1;
                    var s1 = x - i0;
                    var s0 = 1 - s1;
                    var t1 = y - j0;
                    var t0 = 1 - t1;
                    var ix = this.IX(i, j);
                    d[ix] = s0 * (t0 * d0[this.IX(i0, j0)] + t1 * d0[this.IX(i0, j1)]) + s1 * (t0 * d0[this.IX(i1, j0)] + t1 * d0[this.IX(i1, j1)]);
                }
            }
            this.setBoundary(bound, d);
        };

        FSolver.prototype.project = function(u, v, p, div) {
            for (var i = 1; i <= this.nx; i++) {
                for (var j = 1; j <= this.ny; j++) {
                    var ix = this.IX(i, j);
                    div[ix] = -0.5 * ((u[this.IX(i + 1, j)] - u[this.IX(i - 1, j)]) / this.nx + (v[this.IX(i, j + 1)] - v[this.IX(i, j - 1)]) / this.ny);
                    p[ix] = 0;
                }
            }
            this.setBoundary(0, div);
            this.setBoundary(0, p);
            for (var k = 0; k < 20; k++) {
                for (var i = 1; i <= this.nx; i++) {
                    for (var j = 1; j <= this.ny; j++) {
                        var ix = this.IX(i, j);
                        p[ix] = (div[ix] + p[this.IX(i - 1, j)] + p[this.IX(i + 1, j)] + p[this.IX(i, j - 1)] + p[this.IX(i, j + 1)]) / 4;
                    }
                }
                this.setBoundary(0, p);
            }
            for (var i = 1; i <= this.nx; i++) {
                for (var j = 1; j <= this.ny; j++) {
                    var ix = this.IX(i, j);
                    u[ix] -= 0.5 * (p[this.IX(i + 1, j)] - p[this.IX(i - 1, j)]) / this.nx;
                    v[ix] -= 0.5 * (p[this.IX(i, j + 1)] - p[this.IX(i, j - 1)]) / this.ny;
                }
            }
            this.setBoundary(1, u);
            this.setBoundary(2, v);
        };

        FSolver.prototype.updateDensity = function() {
            this.addSource(this.density, this.densityOld);
            this.SWAP('density', 'densityOld');
            this.diffuse(0, this.density, this.densityOld, this.diff);
            this.SWAP('density', 'densityOld');
            this.advect(0, this.density, this.densityOld, this.u, this.v);
        };

        FSolver.prototype.updateVelocity = function() {
            this.addCellVelocity();
            this.SWAP('u', 'uOld');
            this.diffuse(1, this.u, this.uOld, this.visc);
            this.SWAP('v', 'vOld');
            this.diffuse(2, this.v, this.vOld, this.visc);
            this.project(this.u, this.v, this.uOld, this.vOld);
            this.SWAP('u', 'uOld');
            this.SWAP('v', 'vOld');
            this.advect(1, this.u, this.uOld, this.uOld, this.vOld);
            this.advect(2, this.v, this.vOld, this.uOld, this.vOld);
            this.project(this.u, this.v, this.uOld, this.vOld);
        };

        function updateAngleValue() {
            angleValue.innerHTML = angleSlider.value + '°';
        }

        angleSlider.oninput = function() {
            updateAngleValue();
            drawPool();
        };

        function drawPool() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw pool temperature grid
            var cellW = 500 / solver.nx;
            var cellH = 250 / solver.ny;
            var avgT = 0;
            for (var j = 1; j <= solver.ny; j++) {
                for (var i = 1; i <= solver.nx; i++) {
                    var T = solver.density[solver.IX(i, j)];
                    avgT += T;
                    var hue = 240 - (T - 20) * 24;
                    hue = Math.max(0, hue);
                    ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                    ctx.fillRect(50 + (i - 1) * cellW, 100 + (j - 1) * cellH, cellW, cellH);
                }
            }
            avgT /= (solver.nx * solver.ny);

            // Solar cover
            ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.fillRect(50, 100, 500, 10);

            // Draw velocity arrows
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            var skip = 4;
            var arrowScale = 5;
            for (var i = 1; i <= solver.nx; i += skip) {
                for (var j = 1; j <= solver.ny; j += skip) {
                    var ux = solver.u[solver.IX(i, j)];
                    var vy = solver.v[solver.IX(i, j)];
                    var mag = Math.sqrt(ux * ux + vy * vy);
                    if (mag > 0.01) {  // threshold to avoid tiny arrows
                        var dirX = ux / mag;
                        var dirY = vy / mag;
                        var len = Math.min(mag * arrowScale, cellW * 0.8);
                        var x = 50 + (i - 1) * cellW + cellW / 2;
                        var y = 100 + (j - 1) * cellH + cellH / 2;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + dirX * len, y + dirY * len);
                        ctx.stroke();
                    }
                }
            }

            // Jet
            var jetX = 50;
            var jetY = 100 + 125; // mid
            var jetLen = 50;
            var thetaDeg = parseFloat(angleSlider.value);
            var theta = thetaDeg * Math.PI / 180;
            var dx = jetLen * Math.cos(theta);
            var dy = -jetLen * Math.sin(theta); // up negative y
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(jetX, jetY);
            ctx.lineTo(jetX + dx, jetY + dy);
            ctx.stroke();

            // Text
            ctx.font = '16px Arial';
            ctx.fillStyle = 'black';
            ctx.fillText('Avg Pool Temperature: ' + avgT.toFixed(1) + ' °C', 400, 60);
            ctx.fillText('Simulation Time: ' + time + ' units', 400, 80);
        }

        function simulateStep() {
            for (var loop = 0; loop < 5; loop++) { // multiple steps for smoother/faster sim
                // Clear old forces
                solver.uOld.fill(0);
                solver.vOld.fill(0);

                // Add jet force
                var thetaDeg = parseFloat(angleSlider.value);
                var theta = thetaDeg * Math.PI / 180;
                var force = 10; // adjust for suitable flow
                var ux = Math.cos(theta) * force;
                var vy = -Math.sin(theta) * force;
                var i_jet = 1;
                var j_jet = Math.floor(solver.ny / 2);
                solver.uOld[solver.IX(i_jet, j_jet)] = ux;
                solver.vOld[solver.IX(i_jet, j_jet)] = vy;

                // Update velocity
                solver.updateVelocity();

                // Add heat source from cover
                solver.densityOld.fill(0); // clear first
                var T_cover = 40;
                for (var i = 1; i <= solver.nx; i++) {
                    var ix = solver.IX(i, 1);
                    var speed = Math.sqrt(solver.u[ix] * solver.u[ix] + solver.v[ix] * solver.v[ix]);
                    var h = 0.05 + 0.5 * speed; // convection coeff, base + flow dependent
                    var rate = h * (T_cover - solver.density[ix]);
                    solver.densityOld[ix] += rate;
                }

                // Update density
                solver.updateDensity();
            }

            // Compute avg T for rate
            var avgT = 0;
            for (var j = 1; j <= solver.ny; j++) {
                for (var i = 1; i <= solver.nx; i++) {
                    avgT += solver.density[solver.IX(i, j)];
                }
            }
            avgT /= (solver.nx * solver.ny);
            time += 1;
            drawPool();
            if (time > 0) {
                status.innerText = 'Current Heating Rate: ' + ((avgT - 20) / time * 60).toFixed(2) + ' °C/hour (approx)';
            }
        }

        startBtn.onclick = function() {
            if (!interval) {
                interval = setInterval(simulateStep, 100); // faster update
            }
        };

        resetBtn.onclick = function() {
            clearInterval(interval);
            interval = null;
            time = 0;
            solver = new FSolver(80, 40, 0.1, 0.00001, 0.0001);
            drawPool();
            status.innerText = '';
        };

        // Initial draw
        updateAngleValue();
        resetBtn.onclick(); // initialize solver
    </script>
</body>
</html>
