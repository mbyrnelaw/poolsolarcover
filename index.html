<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pool Heat Simulation Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f4f4f5; /* Light gray background */
        }
        /* --- Sky Animation Styles --- */
        .scene-container {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            transition: background-color 1.5s ease;
        }
        .celestial-body {
            width: 50px; height: 50px; border-radius: 50%; position: absolute; left: 50%; bottom: -25px; margin-left: -25px; transition: transform 1.5s linear, opacity 1.5s ease; transform-origin: center center;
        }
        .sun {
            background: radial-gradient(circle, #FFF700, #FFC700, #F5B041); box-shadow: 0 0 40px #FFC700;
        }
        .moon {
            background: #E0E0E0; box-shadow: inset -10px 0 15px -8px rgba(0,0,0,0.4), 0 0 15px #f5f5f5;
        }
        #stars {
            width: 100%; height: 100%; position: absolute; top: 0; left: 0; transition: opacity 2s ease;
        }
        .star {
            position: absolute; background-color: white; border-radius: 50%; animation: twinkle 4s infinite alternate;
        }
        @keyframes twinkle { from { opacity: 0.5; } to { opacity: 1; } }
        #clouds {
            width: 100%; height: 100%; position: absolute; top: 0; left: 0; transition: opacity 2s ease;
        }
        .cloud {
            position: absolute; background: #fff; border-radius: 50%; width: 80px; height: 80px; opacity: 0.8; animation: drift linear infinite;
        }
        .cloud::before, .cloud::after {
            content: ''; position: absolute; background: #fff; border-radius: 50%;
        }
        .cloud::before { width: 50px; height: 50px; top: -20px; left: 15px; }
        .cloud::after { width: 60px; height: 60px; top: 0; left: -30px; }
        @keyframes drift { from { transform: translateX(-150px); } to { transform: translateX(100vw); } }

        /* --- Dashboard Styles --- */
        .data-box {
            border: 2px solid;
            transition: background-color 0.5s linear, border-color 0.5s ease, color 0.5s linear;
        }
        .data-box h3 { font-weight: 600; }
        .data-box p { font-weight: 700; font-size: 1.875rem; }
        .cover-box.off {
            background-color: transparent !important; border-color: transparent !important; color: #d1d5db;
        }
        .cover-box.off h3, .cover-box.off p { opacity: 0; }
        
        /* --- Control Box Styles --- */
        .control-box {
            height: 56px;
            border: 2px solid #9ca3af;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            background-color: #f3f4f6;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-weight: 600;
            color: #4b5563;
            line-height: 1;
        }
        .control-box.active {
            background-color: #3b82f6;
            border-color: #1d4ed8;
            box-shadow: inset 0 2px 4px 0 rgba(0,0,0,0.2);
            color: white;
        }
        .skimmer-box { 
            width: 56px; 
            font-size: 0.7rem;
        }
        .jet-box { 
            width: 56px; 
            background-color: #60a5fa;
            border-color: #2563eb;
        }
        .jet-box svg {
            width: 24px; height: 24px; stroke-width: 2.5; stroke: white;
        }
        .pump-box {
            width: 56px;
            font-size: 0.7rem;
        }
        .pump-box.active {
            background-color: #22c55e; /* green-500 */
            border-color: #15803d; /* green-700 */
            color: white;
        }
        .hidden-svg, .hidden-line { display: none; }
        #connection-lines {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: -1;
        }
        /* Style to prevent jitter */
        .value-span {
            display: inline-block;
            min-width: 5rem; /* Adjust as needed */
            text-align: left;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }
        .q-display {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.75rem;
            color: #4b5563;
            text-align: center;
            padding: 0.25rem 0;
        }
    </style>
</head>
<body class="bg-gray-100 p-4">

    <div class="max-w-2xl mx-auto">
        <!-- Header -->
        <div class="flex justify-between items-center mb-6">
             <h1 class="text-3xl font-bold text-gray-800">Pool Simulation</h1>
             <div class="text-right">
                <p id="day-display" class="font-mono text-sm text-gray-500">Day 1</p>
                <p id="time-display" class="font-mono text-xl text-gray-700">12:00 PM</p>
             </div>
        </div>

        <!-- Controls -->
        <div class="bg-white p-4 rounded-lg shadow-md mb-6">
            <div class="flex flex-wrap justify-center gap-2">
                <button data-season="Summer" class="season-btn px-4 py-2 text-sm font-semibold rounded-md bg-blue-600 text-white">Summer</button>
                <button data-season="Fall" class="season-btn px-4 py-2 text-sm font-semibold rounded-md bg-white text-gray-700">Fall</button>
                <button data-season="Winter" class="season-btn px-4 py-2 text-sm font-semibold rounded-md bg-white text-gray-700">Winter</button>
                <button data-season="Spring" class="season-btn px-4 py-2 text-sm font-semibold rounded-md bg-white text-gray-700">Spring</button>
            </div>
        </div>

        <!-- Data Display Stack -->
        <div id="dashboard-stack" class="space-y-1 relative">
            <svg id="connection-lines"></svg>
            <div id="air-temp-box" class="data-box p-4 rounded-lg text-center border-gray-300 bg-gray-100 h-32 relative overflow-hidden flex flex-col justify-center">
                <div id="scene-container" class="scene-container">
                    <div id="stars"></div>
                    <div id="clouds" id="clouds"></div>
                    <div class="celestial-body sun" id="sun"></div>
                    <div class="celestial-body moon" id="moon"></div>
                </div>
                <div class="relative z-10 text-white text-lg" style="text-shadow: 1px 1px 3px rgba(0,0,0,0.6);">
                    <p>
                        <span>Air Temp (<span id="season-display" class="font-bold">Summer</span>):</span>
                        <span id="air-temp-value" class="font-bold value-span">-- °F</span>
                    </p>
                    <p>
                        <span>Evap. Loss:</span>
                        <span id="evap-loss-value" class="font-bold value-span">-- °F/hr</span>
                    </p>
                </p>
                </div>
            </div>
            
            <div class="grid grid-cols-[124px 1fr] gap-3">
                <div class="text-xs text-gray-500 pt-2">Adjust circulation below:</div>
                <div id="cover-box" class="cover-box data-box p-4 rounded-lg text-center border-blue-400 bg-blue-100 relative">
                    <div class="text-center">
                        <h3 class="text-base">Cover Temp</h3>
                        <p id="cover-temp-display" class="text-blue-800 value-span">-- °F</p>
                    </div>
                    <button id="toggle-cover-btn" class="absolute right-4 top-1/2 -translate-y-1/2 px-4 py-2 bg-slate-500 text-white text-sm font-semibold rounded-lg shadow-md hover:bg-slate-600">Remove Cover</button>
                </div>
            </div>

            <div id="q-cover-top" class="q-display ml-[136px]">Q: -- W/m²</div>

            <!-- Grid Layout for water controls and display -->
            <div id="water-grid" class="grid grid-cols-[56px 56px 1fr] gap-3 items-center">
                <!-- Row 1 -->
                <div id="skimmer-top-box" class="control-box skimmer-box" title="Set skimmer to top">Skim</div>
                <div></div>
                <div id="water-top-temp-box" class="data-box p-4 rounded-lg text-center text-white">
                    <h3>Top Water Temp</h3>
                    <p id="water-top-temp-display" class="value-span">-- °F</p>
                </div>

                <!-- Q Display between Top and mid -->
                <div></div>
                <div></div>
                <div id="q-top-mid" class="q-display">Q: -- W/m²</div>

                <!-- Row 2 -->
                <div id="pump-box" class="control-box pump-box" title="Toggle Pump">Pump</div>
                <div id="jet-control-box" class="control-box jet-box" title="Cycle Jet Direction">
                    <svg id="jet-arrow-up" class="hidden-svg" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M4.5 19.5l15-15m0 0H8.25m11.25 0v11.25" /></svg>
                    <svg id="jet-arrow-horizontal" class="hidden-svg" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 4.5L21 12m0 0l-7.5 7.5M21 12H3" /></svg>
                    <svg id="jet-arrow-down" class="hidden-svg" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M4.5 4.5l15 15m0 0V8.25m0 11.25H8.25" /></svg>
                </div>
                <div id="water-mid-temp-box" class="data-box p-4 rounded-lg text-center text-white">
                    <h3>Mid Water Temp</h3>
                    <p id="water-mid-temp-display" class="value-span">-- °F</p>
                </div>

                <!-- Q Display between Mid and Bottom -->
                <div></div>
                <div></div>
                <div id="q-mid-bot" class="q-display">Q: -- W/m²</div>

                <!-- Row 3 -->
                <div id="skimmer-bottom-box" class="control-box skimmer-box" title="Set skimmer to bottom">Drain</div>
                <div></div>
                <div id="water-bottom-temp-box" class="data-box p-4 rounded-lg text-center text-white">
                    <h3>Bottom Water Temp</h3>
                    <p id="water-bottom-temp-display" class="value-span">-- °F</p>
                </div>
            </div>
        </div>
        
        <div class="mt-6 text-center">
            <button id="reset-btn" class="px-8 py-2 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-600">Reset Simulation</button>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const sceneContainer = document.getElementById('scene-container');
        const sunElement = document.getElementById('sun');
        const moonElement = document.getElementById('moon');
        const starsContainer = document.getElementById('stars');
        const cloudsContainer = document.getElementById('clouds');
        const seasonDisplay = document.getElementById('season-display');
        const airTempValue = document.getElementById('air-temp-value');
        const evapLossValue = document.getElementById('evap-loss-value');
        const coverBox = document.getElementById('cover-box');
        const coverTempDisplay = document.getElementById('cover-temp-display');
        const toggleCoverBtn = document.getElementById('toggle-cover-btn');
        const waterTopTempBox = document.getElementById('water-top-temp-box');
        const waterTopTempDisplay = document.getElementById('water-top-temp-display');
        const waterMidTempBox = document.getElementById('water-mid-temp-box');
        const waterMidTempDisplay = document.getElementById('water-mid-temp-display');
        const waterBottomTempBox = document.getElementById('water-bottom-temp-box');
        const waterBottomTempDisplay = document.getElementById('water-bottom-temp-display');
        const timeDisplay = document.getElementById('time-display');
        const dayDisplay = document.getElementById('day-display');
        const seasonBtns = document.querySelectorAll('.season-btn');
        const resetBtn = document.getElementById('reset-btn');
        const skimmerTopBox = document.getElementById('skimmer-top-box');
        const skimmerBottomBox = document.getElementById('skimmer-bottom-box');
        const jetControlBox = document.getElementById('jet-control-box');
        const pumpBox = document.getElementById('pump-box');
        const dashboardStack = document.getElementById('dashboard-stack');
        const connectionLinesSVG = document.getElementById('connection-lines');
        const qCoverTopDisplay = document.getElementById('q-cover-top');
        const qTopMidDisplay = document.getElementById('q-top-mid');
        const qMidBotDisplay = document.getElementById('q-mid-bot');
        const jetArrows = {
            up: document.getElementById('jet-arrow-up'),
            horizontal: document.getElementById('jet-arrow-horizontal'),
            down: document.getElementById('jet-arrow-down')
        };

        // --- Simulation Parameters (Physics calculations in Celsius) ---
        const NUM_WATER_LAYERS = 40;
        const INITIAL_WATER_TEMP_C = 18.33; // 65°F
        const K_COVER = 0.015; // Adjusted for realistic U-value ~3 W/m²K
        const K_WATER = 0.6;
        const DX_COVER = 0.005;
        const DX_WATER = 0.04;
        const AREA = 1.0;
        const SIM_SPEED = 10; // dt in seconds per tick
        const RHO_WATER = 1000;
        const CP_WATER = 4186;
        const COVER_CAPACITY = 1000; // J/m²K, low for thin cover
        const LAYER_CAPACITY = RHO_WATER * CP_WATER * DX_WATER; // ~167440 J/m²K
        const SIGMA = 5.67e-8;
        const EPSILON = 0.95;
        const ALPHA_WATER = 0.9;
        const ALPHA_COVER = 0.8;
        const TRANSMIT_COVER = 0.1;

        // --- Seasonal Data (in Celsius) ---
        const seasons = {
            Summer: { dayTemp: 33, nightTemp: 24, dayLength: 14, humidity: 0.75, wind: 2.5, solarMax: 1000 },
            Fall:   { dayTemp: 28, nightTemp: 18, dayLength: 11, humidity: 0.65, wind: 3.0, solarMax: 700 },
            Winter: { dayTemp: 22, nightTemp: 10, dayLength: 10, humidity: 0.60, wind: 3.5, solarMax: 500 },
            Spring: { dayTemp: 29, nightTemp: 17, dayLength: 13, humidity: 0.60, wind: 4.0, solarMax: 800 }
        };

        // --- Convection Model Data ---
        const convectionConditions = {
            A: { top_cover: 0.10, top_mid: 0.01, mid_bot: 0.00, top_bot: 0.00 },
            B: { top_cover: 0.01, top_mid: 0.05, mid_bot: 0.00, top_bot: 0.00 },
            C: { top_cover: 0.01, top_mid: 0.05, mid_bot: 0.02, top_bot: 0.00 },
            D: { top_cover: 0.25, top_mid: 0.05, mid_bot: 0.10, top_bot: 0.10 },
            E: { top_cover: 0.00, top_mid: 0.00, mid_bot: 0.10, top_bot: 0.00 },
            F: { top_cover: 0.00, top_mid: 0.00, mid_bot: 0.15, top_bot: 0.00 },
            G: { top_cover: 0.30, top_mid: 0.10, mid_bot: 0.10, top_bot: 0.05 },
            H: { top_cover: 0.01, top_mid: 0.05, mid_bot: 0.05, top_bot: 0.00 },
            I: { top_cover: 0.00, top_mid: 0.00, mid_bot: 0.00, top_bot: 0.00 }
        };

        // --- State Variables ---
        let mainInterval;
        let isCoverOn = true;
        let coverTempC = 15.0;
        let waterTempsC = new Array(NUM_WATER_LAYERS).fill(INITIAL_WATER_TEMP_C);
        let currentSeason = 'Summer';
        let simTime = 12 * 60;
        let lastSimTime = simTime;
        let dayCount = 1;
        let isTopSkimActive = true;
        let isBottomDrainActive = false;
        const jetDirections = ['up', 'horizontal', 'down'];
        let jetDirectionIndex = 2; // Default to 'down'
        let isPumpOn = true;

        // --- Helper Functions ---
        function celsiusToFahrenheit(c) { return c * 9 / 5 + 32; }
        function temperatureToColor(tempF, minTempF = 50, maxTempF = 105, forText = false) {
            const clampedTemp = Math.max(minTempF, Math.min(tempF, maxTempF));
            const normalized = (clampedTemp - minTempF) / (maxTempF - minTempF);
            const hue = 240 * (1 - normalized);
            const saturation = forText ? '80%' : '90%';
            const lightness = forText ? '30%' : '50%';
            return `hsl(${hue}, ${saturation}, ${lightness})`;
        }
        function getSatVaporPressure(t) {
            return 6.112 * Math.exp(17.67 * t / (t + 243.5)); // hPa
        }

        // --- Scene and UI Update Functions ---
        function createStars() { starsContainer.innerHTML = ''; for (let i = 0; i < 100; i++) { const star = document.createElement('div'); star.className = 'star'; star.style.left = `${Math.random() * 100}%`; star.style.top = `${Math.random() * 100}%`; const size = Math.random() * 2 + 1; star.style.width = `${size}px`; star.style.height = `${size}px`; star.style.animationDelay = `${Math.random() * 4}s`; starsContainer.appendChild(star); } }
        function createClouds() { cloudsContainer.innerHTML = ''; for (let i = 0; i < 4; i++) { const cloud = document.createElement('div'); cloud.className = 'cloud'; cloud.style.top = `${Math.random() * 50 + 5}%`; cloud.style.scale = `${Math.random() * 0.4 + 0.4}`; cloud.style.animationDuration = `${Math.random() * 60 + 50}s`; cloud.style.animationDelay = `-${Math.random() * 50}s`; cloudsContainer.appendChild(cloud); } }
        function updateCelestialBodies(hour, sunPower) { const orbitRadius = sceneContainer.offsetWidth / 2.2; const angle = (simTime / (24 * 60)) * (2 * Math.PI) - (Math.PI / 2); const sunX = orbitRadius * Math.cos(angle); const sunY = orbitRadius * Math.sin(angle); sunElement.style.transform = `translate(${sunX}px, ${sunY}px)`; const moonX = orbitRadius * Math.cos(angle + Math.PI)); const moonY = orbitRadius * Math.sin(angle + Math.PI); moonElement.style.transform = `translate(${moonX}px, ${moonY}px)`; sunElement.style.opacity = sunPower > 0 ? sunPower * 1.2 : 0; moonElement.style.opacity = 1 - (sunPower > 0 ? sunPower * 1.5 : 0); starsContainer.style.opacity = 1 - (sunPower > 0 ? sunPower * 2 : 0); cloudsContainer.style.opacity = sunPower > 0 ? sunPower : 0.1; }
        function updateEnvironment(hour) { const seasonData = seasons[currentSeason]; const sunrise = 12 - seasonData.dayLength / 2; const sunset = 12 + seasonData.dayLength / 2; const tempRange = seasonData.dayTemp - seasonData.nightTemp; const avgTemp = (seasonData.dayTemp + seasonData.nightTemp) / 2; const tempOffset = tempRange / 2 * Math.sin((hour - sunrise - 1) * Math.PI / (sunset - sunrise + 4)); const ambientTempC = avgTemp + tempOffset; let sunPower = 0; if (hour > sunrise && hour < sunset) { sunPower = Math.sin((hour - sunrise) / seasonData.dayLength * Math.PI); } const nightColor = [12, 20, 69], dayColor = [135, 206, 235], dawnColor = [253, 230, 138]; let skyColor; if (hour < sunrise - 1 || hour > sunset + 1) skyColor = nightColor; else if (hour > sunrise + 1 && hour < sunset - 1) skyColor = dayColor; else { let factor = (hour < 12) ? (hour - (sunrise - 1)) / 2 : ((sunset + 1) - hour) / 2; factor = Math.max(0, Math.min(1, factor)); skyColor = dayColor.map((c, i) => c * factor + dawnColor[i] * (1 - factor)); } sceneContainer.style.backgroundColor = `rgb(${skyColor.join(',')`; return { ambientTempC, sunPower }; }

        // --- Convection Model ---
        function applyConvection(temps, currentCoverTemp) {
            if (!isPumpOn) return { modifiedTemps: temps, modifiedCoverTemp: currentCoverTemp };

            const currentJet = jetDirections[jetDirectionIndex];
            let conditionKey;

            if (isTopSkimActive && !isBottomDrainActive) { // Skimmer only
                if (currentJet === 'up') conditionKey = 'A';
                else if (currentJet === 'horizontal') conditionKey = 'B';
                else conditionKey = 'C';
            } else if (!isTopSkimActive && isBottomDrainActive) { // Drain only
                if (currentJet === 'up') conditionKey = 'D';
                else if (currentJet === 'horizontal') conditionKey = 'E';
                else conditionKey = 'F';
            } else if (isTopSkimActive && isBottomDrainActive) { // Both
                if (currentJet === 'up') conditionKey = 'G';
                else if (currentJet === 'horizontal') conditionKey = 'H';
                else conditionKey = 'I';
            } else {
                return { modifiedTemps: temps, modifiedCoverTemp: currentCoverTemp };
            }

            const mods = convectionConditions[conditionKey];
            if (!mods) return { modifiedTemps: temps, modifiedCoverTemp: currentCoverTemp };

            const oneThird = Math.floor(NUM_WATER_LAYERS / 3);
            const twoThirds = Math.floor(NUM_WATER_LAYERS * 2 / 3);

            let newTemps = [...temps];
            let newCoverTemp = currentCoverTemp;

            const CONVE_TICK_FACTOR = (SIM_SPEED / 60); 

            const applyMix = (t1, t2, percent) => {
                const mixRate = (percent / 100) * CONVE_TICK_FACTOR;
                const avg = (t1 + t2) / 2;
                const change1 = (avg - t1) * mixRate;
                const change2 = (avg - t2) * mixRate;
                return { newT1: t1 + change1, newT2: t2 + change2 };
            };

            let topAvgC = newTemps.slice(0, oneThird).reduce((a, b) => a + b, 0) / oneThird;
            let midAvgC = newTemps.slice(oneThird, twoThirds).reduce((a, b) => a + b, 0) / (twoThirds - oneThird);
            let botAvgC = newTemps.slice(twoThirds).reduce((a, b) => a + b, 0) / (NUM_WATER_LAYERS - twoThirds);

            if (mods.top_cover > 0) {
                const { newT1, newT2 } = applyMix(newCoverTemp, topAvgC, mods.top_cover);
                newCoverTemp = newT1;
                const topChange = newT2 - topAvgC;
                for (let i = 0; i < oneThird; i++) newTemps[i] += topChange;
            }

            if (mods.top_mid > 0) {
                const { newT1, newT2 } = applyMix(topAvgC, midAvgC, mods.top_mid);
                const topChange = newT1 - topAvgC;
                const midChange = newT2 - midAvgC;
                for (let i = 0; i < oneThird; i++) newTemps[i] += topChange;
                for (let i = oneThird; i < twoThirds; i++) newTemps[i] += midChange;
            }
            
            if (mods.mid_bot > 0) {
                const { newT1, newT2 } = applyMix(midAvgC, botAvgC, mods.mid_bot);
                const midChange = newT1 - midAvgC;
                const botChange = newT2 - botAvgC;
                for (let i = oneThird; i < twoThirds; i++) newTemps[i] += midChange;
                for (let i = twoThirds; i < NUM_WATER_LAYERS; i++) newTemps[i] += botChange;
            }

            if (mods.top_bot > 0) {
                const { newT1, newT2 } = applyMix(topAvgC, botAvgC, mods.top_bot);
                const topChange = newT1 - topAvgC;
                const botChange = newT2 - botAvgC;
                for (let i = 0; i < oneThird; i++) newTemps[i] += topChange;
                for (let i = twoThirds; i < NUM_WATER_LAYERS; i++) newTemps[i] += botChange;
            }

            return { modifiedTemps: newTemps, modifiedCoverTemp: newCoverTemp };
        }

        // --- Main Simulation Loop ---
        function mainLoop() {
            lastSimTime = simTime;
            simTime = (simTime + SIM_SPEED) % (24 * 60);
            if (simTime < lastSimTime) {
                dayCount++;
            }

            const hour = simTime / 60;
            const { ambientTempC, sunPower } = updateEnvironment(hour);
            const seasonData = seasons[currentSeason];
            let nextWaterTempsC = [...waterTempsC];
            let nextCoverTempC = coverTempC;

            // Conduction between water layers
            for (let i = 0; i < NUM_WATER_LAYERS - 1; i++) {
                const heatFlow = K_WATER * (nextWaterTempsC[i] - nextWaterTempsC[i + 1]) / DX_WATER; // W/m²
                const dT = heatFlow * SIM_SPEED / LAYER_CAPACITY;
                nextWaterTempsC[i] -= dT;
                nextWaterTempsC[i + 1] += dT;
            }

            // Determine top surface
            let topTemp = isCoverOn ? nextCoverTempC : nextWaterTempsC[0];
            let topCapacity = isCoverOn ? COVER_CAPACITY : LAYER_CAPACITY;

            // Solar heating
            const solarFlux = seasonData.solarMax * sunPower; // W/m²
            if (isCoverOn) {
                const dT_cover_solar = ALPHA_COVER * solarFlux * SIM_SPEED / COVER_CAPACITY;
                nextCoverTempC += dT_cover_solar;
                const dT_water_trans = TRANSMIT_COVER * solarFlux * SIM_SPEED / LAYER_CAPACITY;
                nextWaterTempsC[0] += dT_water_trans;
            } else {
                const dT_water_solar = ALPHA_WATER * solarFlux * SIM_SPEED / LAYER_CAPACITY;
                nextWaterTempsC[0] += dT_water_solar;
            }

            // Radiation loss
            const T_top_k = topTemp + 273;
            const T_sky_k = ambientTempC + 273 - 12;
            let Q_rad = EPSILON * SIGMA * (Math.pow(T_top_k, 4) - Math.pow(T_sky_k, 4)); // W/m²
            let dT_rad = Q_rad * SIM_SPEED / topCapacity;
            if (isCoverOn) nextCoverTempC -= dT_rad;
            else nextWaterTempsC[0] -= dT_rad;

            // Convective loss
            const h_conv = 5 + 3.5 * seasonData.wind;
            let Q_conv = h_conv * (topTemp - ambientTempC); // W/m²
            let dT_conv = Q_conv * SIM_SPEED / topCapacity;
            if (isCoverOn) nextCoverTempC -= dT_conv;
            else nextWaterTempsC[0] -= dT_conv;

            // Evaporation loss
            const Pw = getSatVaporPressure(topTemp);
            const Pa = seasonData.humidity * getSatVaporPressure(ambientTempC);
            const deltaP = Math.max(0, Pw - Pa);
            const evapF = isCoverOn ? 0.05 : 1;
            let Q_evap = evapF * (25 + 19 * seasonData.wind) * deltaP; // W/m²
            let dT_evap = Q_evap * SIM_SPEED / topCapacity;
            if (isCoverOn) nextCoverTempC -= dT_evap;
            else nextWaterTempsC[0] -= dT_evap;

            // Conduction from cover to water (if cover on)
            if (isCoverOn) {
                const heatFlow_cover_water = K_COVER * (nextCoverTempC - nextWaterTempsC[0]) / DX_COVER; // W/m²
                const dT_cover = heatFlow_cover_water * SIM_SPEED / COVER_CAPACITY;
                const dT_water = heatFlow_cover_water * SIM_SPEED / LAYER_CAPACITY;
                nextCoverTempC -= dT_cover;
                nextWaterTempsC[0] += dT_water;
            }

            // Apply pump convection/mixing
            const convectionResult = applyConvection(nextWaterTempsC, nextCoverTempC);
            nextWaterTempsC = convectionResult.modifiedTemps;
            nextCoverTempC = convectionResult.modifiedCoverTemp;

            waterTempsC = nextWaterTempsC;
            coverTempC = nextCoverTempC;
            updateDisplays(ambientTempC, Q_evap);
            updateCelestialBodies(hour, sunPower);
        }

        function updateDisplays(ambientTempC, Q_evap) {
            const h = Math.floor(simTime / 60);
            const m = simTime % 60;
            const ampm = h >= 12 ? 'PM' : 'AM';
            const displayHour = h % 12 === 0 ? 12 : h % 12;
            timeDisplay.textContent = `${displayHour}:${m.toString().padStart(2, '0')} ${ampm}`;
            dayDisplay.textContent = `Day ${dayCount}`;
            airTempValue.textContent = `${celsiusToFahrenheit(ambientTempC).toFixed(1)} °F`;
            const lossPerHourC = (Q_evap / (isCoverOn ? COVER_CAPACITY : LAYER_CAPACITY)) * 3600;
            const lossPerHourF = lossPerHourC * 9 / 5;
            evapLossValue.textContent = `${lossPerHourF.toFixed(2)} °F/hr`;
            coverTempDisplay.textContent = isCoverOn ? `${celsiusToFahrenheit(coverTempC).toFixed(1)} °F` : '-- °F';
            const oneThird = Math.floor(NUM_WATER_LAYERS / 3);
            const twoThirds = Math.floor(NUM_WATER_LAYERS * 2 / 3);
            const topThirdTemps = waterTempsC.slice(0, oneThird);
            const midThirdTemps = waterTempsC.slice(oneThird, twoThirds);
            const bottomThirdTemps = waterTempsC.slice(twoThirds);
            const topAvgC = topThirdTemps.reduce((a, b) => a + b, 0) / topThirdTemps.length;
            const midAvgC = midThirdTemps.reduce((a, b) => a + b, 0) / midThirdTemps.length;
            const bottomAvgC = bottomThirdTemps.reduce((a, b) => a + b, 0) / bottomThirdTemps.length;
            const topTempF = celsiusToFahrenheit(topAvgC);
            const midTempF = celsiusToFahrenheit(midAvgC);
            const bottomTempF = celsiusToFahrenheit(bottomAvgC);
            waterTopTempDisplay.textContent = `${topTempF.toFixed(1)} °F`;
            waterMidTempDisplay.textContent = `${midTempF.toFixed(1)} °F`;
            waterBottomTempDisplay.textContent = `${bottomTempF.toFixed(1)} °F`;
            waterTopTempBox.style.backgroundColor = temperatureToColor(topTempF);
            waterTopTempBox.style.borderColor = temperatureToColor(topTempF, 50, 105, true);
            waterMidTempBox.style.backgroundColor = temperatureToColor(midTempF);
            waterMidTempBox.style.borderColor = temperatureToColor(midTempF, 50, 105, true);
            waterBottomTempBox.style.backgroundColor = temperatureToColor(bottomTempF);
            waterBottomTempBox.style.borderColor = temperatureToColor(bottomTempF, 50, 105, true);
            
            const dx_third = (NUM_WATER_LAYERS / 3) * DX_WATER;
            const q_cover_top = isCoverOn ? (K_COVER * (coverTempC - topAvgC) / DX_COVER) : 0;
            const q_top_mid = K_WATER * (topAvgC - midAvgC) / dx_third;
            const q_mid_bot = K_WATER * (midAvgC - bottomAvgC) / dx_third;
            
            qCoverTopDisplay.innerHTML = `Q: ${q_cover_top.toFixed(1)} W/m² <span class="${q_cover_top > 0 ? 'text-red-500' : 'text-blue-500'}">${q_cover_top > 0 ? '↓' : '↑'}</span>`;
            qTopMidDisplay.innerHTML = `Q: ${q_top_mid.toFixed(1)} W/m² <span class="${q_top_mid > 0 ? 'text-red-500' : 'text-blue-500'}">${q_top_mid > 0 ? '↓' : '↑'}</span>`;
            qMidBotDisplay.innerHTML = `Q: ${q_mid_bot.toFixed(1)} W/m² <span class="${q_mid_bot > 0 ? 'text-red-500' : 'text-blue-500'}">${q_mid_bot > 0 ? '↓' : '↑'}</span>`;
        }

        function setSeason(seasonName) {
            currentSeason = seasonName;
            seasonDisplay.textContent = seasonName;
            seasonBtns.forEach(btn => {
                const isSelected = btn.dataset.season === seasonName;
                btn.classList.toggle('bg-blue-600', isSelected);
                btn.classList.toggle('text-white', isSelected);
                btn.classList.toggle('bg-white', !isSelected);
                btn.classList.toggle('text-gray-700', !isSelected);
            });
        }

        function toggleCover() {
            isCoverOn = !isCoverOn;
            coverBox.classList.toggle('off', !isCoverOn);
            toggleCoverBtn.textContent = isCoverOn ? 'Remove Cover' : 'Add Cover';
        }

        function updateSkimmerVisuals() {
            skimmerTopBox.classList.toggle('active', isTopSkimActive);
            skimmerBottomBox.classList.toggle('active', isBottomDrainActive);
            updateConnectionLines();
        }

        function updateJetVisuals() {
            Object.values(jetArrows).forEach(arrow => arrow.classList.add('hidden-svg'));
            const currentDirection = jetDirections[jetDirectionIndex];
            jetArrows[currentDirection].classList.remove('hidden-svg');
        }
        
        function updatePumpVisuals() {
            pumpBox.classList.toggle('active', isPumpOn);
            updateConnectionLines();
        }

        function updateConnectionLines() {
            connectionLinesSVG.innerHTML = '';
            if (!isPumpOn) return; // Hide all lines if pump is off

            const stackRect = dashboardStack.getBoundingClientRect();
            
            const getCenter = (el) => {
                const rect = el.getBoundingClientRect();
                return {
                    x: rect.left + rect.width / 2 - stackRect.left,
                    y: rect.top + rect.height / 2 - stackRect.top
                };
            };

            const pumpCenter = getCenter(pumpBox);
            const jetCenter = getCenter(jetControlBox);
            const topSkimCenter = getCenter(skimmerTopBox);
            const bottomSkimCenter = getCenter(skimmerBottomBox);
            const topWaterCenter = getCenter(waterTopTempBox);
            const bottomWaterCenter = getCenter(waterBottomTempBox);

            const createLine = (p1, p2, isHidden = false) => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', p1.x);
                line.setAttribute('y1', p1.y);
                line.setAttribute('x2', p2.x);
                line.setAttribute('y2', p2.y);
                line.setAttribute('stroke', '#3b82f6');
                line.setAttribute('stroke-width', '3');
                if (isHidden) line.classList.add('hidden');
                connectionLinesSVG.appendChild(line);
            };

            createLine(pumpCenter, jetCenter);
            createLine(topSkimCenter, pumpCenter, !isTopSkimActive);
            createLine(bottomSkimCenter, pumpCenter, !isBottomDrainActive);
            createLine(topSkimCenter, topWaterCenter, !isTopSkimActive);
            createLine(bottomSkimCenter, bottomWaterCenter, !isBottomDrainActive);
        }

        function resetSimulation() {
            clearInterval(mainInterval);
            simTime = 12 * 60;
            lastSimTime = simTime;
            dayCount = 1;
            isCoverOn = true;
            isTopSkimActive = true;
            isBottomDrainActive = false;
            jetDirectionIndex = 2; // Default to 'down'
            isPumpOn = true;
            updateSkimmerVisuals();
            updateJetVisuals();
            updatePumpVisuals();
            coverBox.classList.remove('off');
            toggleCoverBtn.textContent = 'Remove Cover';
            waterTempsC = new Array(NUM_WATER_LAYERS).fill(INITIAL_WATER_TEMP_C);
            coverTempC = seasons.Summer.nightTemp;
            setSeason('Summer');
            createStars();
            createClouds();
            mainInterval = setInterval(mainLoop, 100);
        }

        // --- Event Listeners ---
        toggleCoverBtn.addEventListener('click', toggleCover);
        resetBtn.addEventListener('click', resetSimulation);
        seasonBtns.forEach(btn => { btn.addEventListener('click', () => setSeason(btn.dataset.season)); });
        skimmerTopBox.addEventListener('click', () => { isTopSkimActive = !isTopSkimActive; updateSkimmerVisuals(); });
        skimmerBottomBox.addEventListener('click', () => { isBottomDrainActive = !isBottomDrainActive; updateSkimmerVisuals(); });
        jetControlBox.addEventListener('click', () => {
            jetDirectionIndex = (jetDirectionIndex + 1) % jetDirections.length;
            updateJetVisuals();
        });
        pumpBox.addEventListener('click', () => {
            isPumpOn = !isPumpOn;
            updatePumpVisuals();
        });
        window.addEventListener('resize', updateConnectionLines);

        // --- Initial Setup ---
        window.onload = resetSimulation;
    </script>
</body>
</html>
